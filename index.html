<!DOCTYPE html><html lang="es"><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Auto-Extractor de Cronologías (Sofascore • multi-proxy + diagnóstico)</title>
  <style>
    :root{--bg:#0b1222;--panel:#0f172a;--edge:#18212f;--text:#e2e8f0;--muted:#93a4b3;--accent:#22d3ee;--ok:#34d399;--warn:#f59e0b;--bad:#fb7185}
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial}
    header{padding:18px;border-bottom:1px solid var(--edge);background:#09101e;position:sticky;top:0;z-index:10}
    h1{margin:0;font-size:18px;letter-spacing:.2px}
    main{max-width:1200px;margin:0 auto;padding:18px;display:grid;gap:16px}
    .panel{background:var(--panel);border:1px solid var(--edge);border-radius:16px;padding:14px}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    input,select,textarea,button{background:#09101e;color:var(--text);border:1px solid var(--edge);border-radius:12px;padding:10px 12px}
    input:focus,select:focus,textarea:focus{outline:1px solid var(--accent)}
    button{cursor:pointer}
    .btn{background:#0b1527}
    .btn.primary{background:linear-gradient(90deg,#0ea5b6,#22d3ee);border:none;color:#001319}
    .btn.good{background:linear-gradient(90deg,#059669,#34d399);border:none;color:#00170e}
    .btn.warn{background:linear-gradient(90deg,#b45309,#f59e0b);border:none;color:#1b0d00}
    .muted{color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    pre{white-space:pre-wrap;word-wrap:break-word;margin:0}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;background:#0b1222;border:1px dashed #334155;border-radius:999px}
    .progress{display:none;gap:8px;align-items:center}
    .bar{flex:1;min-width:240px;height:10px;background:#0b1222;border:1px solid #1f2937;border-radius:999px;overflow:hidden}
    .fill{height:100%;width:0%;background:linear-gradient(90deg,#0ea5b6,#22d3ee)}
    .ptext{min-width:120px;text-align:right;font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div class="row" style="align-items:center;justify-content:space-between">
      <h1>Auto-Extractor de Cronologías (Sofascore vía multi-proxy)</h1>
      <div class="muted mono">Stats, tiros, posesión, xG • diagnóstico en vivo</div>
    </div>
  </header>

  <main>
    <!-- PROXY -->
    <section class="panel">
      <h2>1) Proxy CORS</h2>
      <div class="row">
        <label class="chip">Proxy base: <input id="proxyBase" placeholder="(déjalo vacío para usar proxys públicos)" style="min-width:360px"></label>
        <button class="btn" onclick="saveProxy()">Guardar</button>
        <span id="proxyStatus" class="muted"></span>
      </div>
      <div class="muted" style="margin-top:6px">
        Si lo dejas vacío, se usará <code>r.jina.ai</code> primero y otros proxys públicos como respaldo (100% repo).
      </div>
    </section>

    <!-- 6 ESPACIOS -->
    <section class="panel">
      <h2>2) Parámetros</h2>
      <div class="row">
        <input id="equipoA" placeholder="Equipo A">
        <input id="equipoB" placeholder="Equipo B">
        <input id="nA" type="number" min="0" placeholder="# partidos A">
        <input id="nB" type="number" min="0" placeholder="# partidos B">
        <input id="nH2H" type="number" min="0" placeholder="# H2H">
        <input id="competicionGlobal" placeholder="Competición (opcional)">
      </div>
      <div id="progress" class="progress" style="margin-top:10px">
        <div class="bar"><div class="fill" id="pfill"></div></div>
        <div class="ptext" id="ptext">0%</div>
      </div>
      <div class="row" style="margin-top:8px">
        <button class="btn primary" onclick="runAll()">Extraer automáticamente</button>
        <button class="btn" onclick="clearAll()">Limpiar</button>
        <span id="status" class="muted mono"></span>
      </div>
    </section>

    <!-- SALIDA -->
    <section class="panel">
      <h2>3) Salida</h2>
      <pre id="out" class="mono"></pre>
      <div class="row" style="margin-top:8px">
        <button class="btn good" onclick="copyOut()">Copiar</button>
      </div>
    </section>

    <!-- LOG -->
    <section class="panel">
      <h2>Log</h2>
      <pre id="log" class="mono"></pre>
    </section>

    <!-- DIAGNÓSTICO DETALLADO -->
    <section class="panel">
      <h2>Diagnóstico</h2>
      <pre id="diag" class="mono"></pre>
    </section>
  </main>

  <script>
  // =================== Estado/UI ===================
  const S = {
    proxyBase: localStorage.getItem('proxyBase')||'',
    lastProxy: localStorage.getItem('activeProxy')||''
  };
  const $ = s => document.querySelector(s);

  function saveProxy(){
    // Si quieres 100% repo, deja vacío este campo (recomendado)
    S.proxyBase=$('#proxyBase').value.trim().replace(/\/$/,'');
    localStorage.setItem('proxyBase',S.proxyBase);
    updateProxyStatus();
  }
  function updateProxyStatus(){
    $('#proxyStatus').textContent = S.proxyBase
      ? `Usando tu proxy: ${S.proxyBase}`
      : 'Modo 100% repo: r.jina.ai + proxys públicos';
  }
  (function init(){ $('#proxyBase').value=S.proxyBase; updateProxyStatus(); })();

  function log(m){ const el=$('#log'); el.textContent += (el.textContent?'\n':'')+m; }
  function diag(line){ const row=`[${new Date().toLocaleTimeString()}] ${line}`; const el=$('#diag'); el.textContent += (el.textContent?'\n':'')+row; }
  function setStatus(m){ $('#status').textContent=m; }
  function clearAll(){ $('#out').textContent=''; $('#log').textContent=''; $('#diag').textContent=''; setStatus(''); progressHide(); }
  function copyOut(){ const t=$('#out').textContent; if(!t){alert('No hay salida');return;} navigator.clipboard.writeText(t).then(()=>alert('Copiado')); }

  function progressShow(){ $('#progress').style.display='flex'; }
  function progressHide(){ $('#progress').style.display='none'; }
  function progress(p,msg){ progressShow(); $('#pfill').style.width=Math.max(0,Math.min(100,p))+'%'; $('#ptext').textContent=Math.round(p)+'%'; if(msg) setStatus(msg); }

  // =================== Proxys (prioridad Jina en modo repo) ===================
  function hasProxyBase(){ return !!S.proxyBase; }

  const PROXIES = [
    // Si configuraste un backend propio (Render/Worker), lo probamos primero:
    { name:'Worker',    kind:'worker', active:()=>hasProxyBase(), build:(path)=> `${S.proxyBase.replace(/\/$/,'')}/sofa?path=${encodeURIComponent(path)}` },

    // Públicos (ordenado por estabilidad):
    { name:'Jina',      kind:'public', active:()=>true, build:(path)=> `https://r.jina.ai/http://api.sofascore.com${path}` },
    { name:'AllOrigins',kind:'public', active:()=>true, build:(path)=> `https://api.allorigins.win/raw?url=${encodeURIComponent('https://api.sofascore.com'+path)}` },
    { name:'Thingproxy',kind:'public', active:()=>true, build:(path)=> `https://thingproxy.freeboard.io/fetch/https://api.sofascore.com${path}` },
    { name:'iso-git',   kind:'public', active:()=>true, build:(path)=> `https://cors.isomorphic-git.org/https://api.sofascore.com${path}` },
    { name:'corsproxy', kind:'public', active:()=>true, build:(path)=> `https://corsproxy.io/?${encodeURIComponent('https://api.sofascore.com'+path)}` },
  ];

  const HEALTH = {}; // { name: { fails:number, cooldownUntil:ts } }
  function isOnCooldown(name){ const h=HEALTH[name]; return h && h.cooldownUntil && Date.now()<h.cooldownUntil; }
  function markSuccess(name){ HEALTH[name]={fails:0,cooldownUntil:0}; S.lastProxy=name; localStorage.setItem('activeProxy',name); updateProxyStatus(); }
  function markFail(name){ const h=HEALTH[name]||{fails:0,cooldownUntil:0}; h.fails++; const mins=Math.min(h.fails,5); h.cooldownUntil=Date.now()+mins*60*1000; HEALTH[name]=h; }

  function buildTargets(path){
    // Orden: si hay Worker → primero; luego último OK; luego el resto
    const baseOrder = PROXIES.filter(p=>p.active()).map(p=>p.name);
    const order=[];
    if(hasProxyBase()) order.push('Worker');
    if(S.lastProxy && S.lastProxy!=='Worker') order.push(S.lastProxy);
    for(const n of baseOrder) if(!order.includes(n)) order.push(n);
    return order
      .filter(n=>!isOnCooldown(n))
      .map(n=> PROXIES.find(p=>p.name===n))
      .map(p=>({name:p.name,kind:p.kind,url:p.build(path)}));
  }

  async function fetchWithTimeout(url, ms=10000){
    const ctrl=new AbortController(); const id=setTimeout(()=>ctrl.abort('timeout'),ms);
    try{
      const t0=performance.now();
      const r=await fetch(url,{signal:ctrl.signal});
      const t1=performance.now();
      return { response:r, ms:Math.round(t1-t0), aborted:false };
    }catch(e){ return { response:null, ms:ms, aborted:true, error:e }; }
    finally{ clearTimeout(id); }
  }

  function explainError({status,aborted,error,peek}){
    if(aborted) return 'Timeout (demoró demasiado)';
    if(!status && error) return 'Error de red/CORS del proxy';
    if(status===403) return 'HTTP 403 (bloqueo anti-bot/proxy)';
    if(status===404) return 'HTTP 404 (ruta no encontrada)';
    if(status>=500)  return 'HTTP 5xx (proxy caído)';
    if(peek && /<html|challenge|captcha|page not found/i.test(peek)) return 'Respuesta HTML/challenge';
    return `HTTP ${status||'desconocido'}`;
  }

  // ===== fetchJSON con ROTACIÓN REAL (solo acepta JSON válido) =====
  async function fetchJSON(path){
    const targets=buildTargets(path);
    let last=null;

    for(let i=0;i<targets.length;i++){
      const t=targets[i];
      diag(`Intento ${i+1}/${targets.length} → ${t.name}`);
      const {response,ms,aborted,error}=await fetchWithTimeout(t.url, 10000);

      if(!response){
        last={proxy:t.name,status:0,aborted,error};
        markFail(t.name);
        diag(`❌ ${t.name} sin respuesta · ${explainError(last)} (${ms} ms)`);
        continue;
      }

      const ct=(response.headers.get('content-type')||'').toLowerCase();
      const text=await response.text();
      const peek=text.slice(0,180);

      if(!response.ok){
        last={proxy:t.name,status:response.status,aborted:false,peek};
        markFail(t.name);
        diag(`❌ ${t.name} HTTP ${response.status} (${ms} ms)`);
        continue;
      }

      // Aceptamos solo JSON válido (algunos proxys devuelven text/plain o HTML)
      try{
        const clean=text.replace(/^\uFEFF/,'').trim();
        const json=JSON.parse(clean);
        markSuccess(t.name);
        diag(`✅ ${t.name} OK (${ms} ms)`);
        return json;
      }catch{
        last={proxy:t.name,status:200,aborted:false,peek};
        markFail(t.name);
        diag(`❌ ${t.name} devolvió no-JSON (HTML/challenge). Rotando…`);
        continue;
      }
    }

    const human = last? `${last.proxy}: ${explainError(last)}` : 'sin intentos válidos';
    const err = new Error(`No hay proxy disponible · Último fallo → ${human}`);
    err.detail=last; throw err;
  }

  async function connectivityTest(){
    try{
      const j=await fetchJSON(`/api/v1/search/all?q=barcelona`);
      const ok=!!(j?.teams?.data);
      diag(ok? 'Conectividad OK (search/all)':'Conectividad rara (estructura)');
      return ok;
    }catch(e){
      diag('Conectividad falló: '+(e.message||e));
      throw e;
    }
  }

  // =================== Lógica de negocio ===================
  async function searchTeamByName(name){
    const tries = Array.from(new Set([
      name,
      name.replace(/\s+/g,' ').trim(),
      name.replace(/^fc\s+/i,'FC '),
      name.replace(/\s+cf$/i,' CF')
    ])).filter(Boolean);

    let lastErr=null;
    for(const q of tries){
      try{
        const j=await fetchJSON(`/api/v1/search/all?q=${encodeURIComponent(q)}`);
        const teams=(j?.teams?.data)||[]; if(!teams.length){ lastErr=new Error('Sin coincidencias'); continue; }
        const n=q.toLowerCase();
        const hit = teams.find(t=> (t.name||'').toLowerCase().includes(n) || (t.shortName||'').toLowerCase().includes(n)) || teams[0];
        if(hit) return {id:hit.id,name:hit.name,slug:hit.slug};
      }catch(e){ lastErr=e; }
    }
    throw new Error(`No se encontró equipo: ${name}${lastErr?` (${lastErr.message})`:''}`);
  }

  async function getLastEvents(teamId,count){
    const want=Math.max(count||0,0); const batch=Math.max(want,25);
    const j=await fetchJSON(`/api/v1/team/${teamId}/events/last/${batch}`);
    return (j?.events||[]).slice(0,want);
  }

  async function getIncidents(eventId){
    const j=await fetchJSON(`/api/v1/event/${eventId}/incidents`);
    return (j?.incidents)||[];
  }

  async function getStatistics(eventId){
    const eps=[
      `/api/v1/event/${eventId}/statistics`,
      `/api/v1/event/${eventId}/statistics/overall`,
      `/api/v1/event/${eventId}/statistics?type=total`
    ];
    for(const ep of eps){
      try{
        const j=await fetchJSON(ep);
        const stats = j?.statistics || j?.groups || j?.data || j || null;
        if(!stats) continue;
        return parseStatistics(stats);
      }catch(e){ diag(`stats fallo (${ep}): ${e.message||e}`); }
    }
    return { possessionHome:null, possessionAway:null, shotsHome:null, shotsAway:null, xgHome:null, xgAway:null };
  }

  function parseStatistics(stats){
    let possessionHome=null, possessionAway=null, shotsHome=null, shotsAway=null, xgHome=null, xgAway=null;
    const flat=[]; const push=(n,h,a)=>flat.push({name:(n||'').toString().toLowerCase(),home:h,away:a});

    if(Array.isArray(stats)){
      for(const g of stats){
        if(g?.statisticsItems){ for(const it of g.statisticsItems) push(it.name,it.home,it.away); }
        else if(g?.items){ for(const it of g.items) push(it.name,it.home,it.away); }
        else if(g?.name && (g?.home!=null||g?.away!=null)) push(g.name,g.home,g.away);
      }
    } else if(typeof stats==='object'){
      for(const k of Object.keys(stats)){ const arr=stats[k]; if(Array.isArray(arr)) for(const it of arr) push(it.name,it.home,it.away); }
    }

    const num=v=>{ if(v==null) return null; if(typeof v==='number') return v; const s=String(v).trim(); if(s.endsWith('%')) return parseFloat(s); const n=parseFloat(s.replace(',','.')); return isNaN(n)?null:n; };
    const pick=names=>flat.find(x=>names.some(nm=>x.name.includes(nm)))||null;

    const poss=pick(['possession','posesión','ball possession']); if(poss){ possessionHome=num(poss.home); possessionAway=num(poss.away); }
    const shots=pick(['total shots','shots total','tiros totales','shots']); if(shots){ shotsHome={total:num(shots.home),onTarget:null}; shotsAway={total:num(shots.away),onTarget:null}; }
    const sot=pick(['shots on target','on target','tiros a puerta','tiros al arco']); if(sot){ shotsHome=shotsHome||{total:null,onTarget:null}; shotsAway=shotsAway||{total:null,onTarget:null}; shotsHome.onTarget=num(sot.home); shotsAway.onTarget=num(sot.away); }
    const xg=pick(['xg','expected goals']); if(xg){ xgHome=num(xg.home); xgAway=num(xg.away); }

    return { possessionHome, possessionAway, shotsHome, shotsAway, xgHome, xgAway };
  }

  function normalizeIncident(ev){
    const type=ev.incidentType||ev.type||'';
    const min=ev.time??ev.minute??null;
    const at=ev.addedTime||ev.extraTime||null;
    const player=ev.player?.name||ev.playerName||'';
    const assist=ev.assist1?.name||ev.assist?.name||'';
    const team=!!ev.isHome;
    let detail=type;
    if(type==='goal'){ detail='Gol'; if(ev.isOwnGoal) detail+=' (Auto)'; if(ev.isPenalty) detail+=' (Penalti)'; if(ev.isMissedPenalty) detail='Penalti fallado'; }
    else if(type==='yellowCard') detail='Tarjeta Amarilla';
    else if(type==='redCard') detail='Tarjeta Roja';
    else if(type==='yellowRed') detail='Doble amarilla (roja)';
    else if(type==='substitution') detail='Cambio';
    else if(type==='var') detail='VAR';
    else if(type==='period') detail=ev.text||'Periodo';
    return {min,at,player,assist,team,detail};
  }

  function formatIncidents(incs,home,away){
    return incs.map(normalizeIncident).filter(x=>x.min!=null)
      .sort((a,b)=> (a.min + (a.at||0)/100) - (b.min + (b.at||0)/100))
      .map(ev=>`[${ev.at?ev.min+"+"+ev.at:ev.min}'] ${ev.detail} - ${ev.team?home:away}${ev.player?` - ${ev.player}`:''}${ev.assist?` (Asistencia: ${ev.assist})`:''}`);
  }

  function formatMatch(ev,inc,stats){
    const h=ev.homeTeam?.name||'Local';
    const a=ev.awayTeam?.name||'Visitante';
    const parts=[];
    parts.push(`Fecha: ${ev.startTimestamp?new Date(ev.startTimestamp*1000).toISOString().slice(0,10):'-'}`);
    parts.push(`Competición: ${ev.tournament?.name||'-'}`);
    parts.push(`Equipos: ${h} vs ${a}`);
    parts.push(`Resultado Final: ${ev.homeScore?.current??'-'}-${ev.awayScore?.current??'-'}`);
    if(stats.shotsHome||stats.shotsAway) parts.push(`Tiros Totales: ${h} ${stats.shotsHome?.total??'-'}${stats.shotsHome?.onTarget!=null?` (${stats.shotsHome.onTarget} al arco)`:''}, ${a} ${stats.shotsAway?.total??'-'}${stats.shotsAway?.onTarget!=null?` (${stats.shotsAway.onTarget} al arco)`:''}`);
    if(stats.possessionHome!=null&&stats.possessionAway!=null) parts.push(`Posesión: ${h} ${stats.possessionHome}% , ${a} ${stats.possessionAway}%`);
    if(stats.xgHome!=null&&stats.xgAway!=null) parts.push(`xG: ${h} ${stats.xgHome} , ${a} ${stats.xgAway}`);
    parts.push("\nEventos:");
    parts.push(...inc);
    return parts.join('\n');
  }

  // =================== Flujo principal ===================
  async function connectivityTest(){
    const ok = await fetchJSON(`/api/v1/search/all?q=barcelona`).then(j=>!!(j?.teams?.data));
    if(ok) diag('Conectividad OK (search/all)'); else diag('Conectividad rara (estructura)');
    return ok;
  }

  async function runAll(){
    try{
      clearAll();
      const Aname=$('#equipoA').value.trim();
      const Bname=$('#equipoB').value.trim();
      if(!Aname||!Bname){ alert('Escribe Equipo A y Equipo B'); return; }

      progress(3,'Probando conectividad…');
      await connectivityTest();

      progress(10,'Buscando equipos…');
      const A=await searchTeamByName(Aname); log(`Equipo A: ${A.name}`);
      const B=await searchTeamByName(Bname); log(`Equipo B: ${B.name}`);

      const nA=+($('#nA').value||0), nB=+($('#nB').value||0), nH2H=+($('#nH2H').value||0);
      const total=(nA>0?nA:0)+(nB>0?nB:0)+(nH2H>0?nH2H:0);
      const step = total? Math.max(65/total,2) : 10; let pct=30;

      const blocks=[];
      async function process(ev){
        const [inc,stats]=await Promise.all([ getIncidents(ev.id), getStatistics(ev.id) ]);
        blocks.push( formatMatch(ev, formatIncidents(inc, ev.homeTeam?.name, ev.awayTeam?.name), stats) );
        pct+=step; progress(Math.min(98,pct),'Procesando…');
      }

      if(nA>0){ setStatus(`Descargando últimos ${nA} de ${A.name}…`); const list=await getLastEvents(A.id,nA); for(const ev of list) await process(ev); }
      if(nB>0){ setStatus(`Descargando últimos ${nB} de ${B.name}…`); const list=await getLastEvents(B.id,nB); for(const ev of list) await process(ev); }
      if(nH2H>0){ setStatus(`Buscando H2H ${A.name} vs ${B.name}…`); const cand=await getLastEvents(A.id,Math.max(100,nH2H)); const vsB=cand.filter(e=>e.homeTeam?.id===B.id||e.awayTeam?.id===B.id).slice(0,nH2H); for(const ev of vsB) await process(ev); }

      if(!blocks.length){ alert('Sin resultados con esos parámetros'); setStatus('Sin resultados'); progressHide(); return; }
      $('#out').textContent = `Contexto:\nEquipo A: ${A.name} | Equipo B: ${B.name} | #A: ${$('#nA').value||'0'} | #B: ${$('#nB').value||'0'} | H2H: ${$('#nH2H').value||'0'} | Competición: ${$('#competicionGlobal').value||'-'}\n\n` + blocks.join('\n\n');
      setStatus('Listo ✅'); progress(100,'Completado'); setTimeout(progressHide,800);
    }catch(e){
      log('ERROR: '+(e.message||e));
      if(e.detail){ diag(`Último proxy: ${e.detail.proxy} · ${e.detail.status||'sin status'} · ${e.detail.aborted?'timeout':'red'}`); }
      if(e.bodySnippet){ diag('Snippet respuesta no-JSON: '+e.bodySnippet); }
      setStatus('Error'); progressHide(); alert(e.message||e);
    }
  }
  </script>
</body>
</html>
